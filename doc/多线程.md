#Excutors可以产生哪些线程池
newCachedThreadPool  可缓存的线程池  可灵活回收空闲线程
newFixedThreadPool 定长线程池  控制线程的最大并发数  超出会在队列中等待
newScheduledThreadPool 创建一个定长线程池 支持定时和周期性任务
newSingleThreadExecutor 单线程化的线程池 只有一个工作线程来执行任务 有顺序的执行

##线程池的参数
public ThreadPoolExecutor(int corePoolSize, 
int maximumPoolSize, 
long keepAliveTime,
 TimeUnit unit, 
 BlockingQueue workQueue, 
 ThreadFactory threadFactory)
 { this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler);

#线程池的饱和策略： 
1.Abort策略:默认策略,新任务提交时直接抛出未检查的异常RejectedExecutionException 
2.CallerRuns策略:为调节机制,既不抛弃任务也不抛出异常,而是将某些任务回退到调用者不会在线程池的线程中执行新的任务，而是在调用exector的线程中运行新的任务。
3.Discard策略:新提交的任务被抛弃。 new ThreadPoolExecutor().DiscardPolicy() 
4.DiscardOldest策略:队列的是“队头”的任务,然后尝试提交新的任务。对头任务被丢弃（不适合工作队列为优先队列场景）


~新建线程的两种方式  extends Thread 或 implements Runnable接口
Thread是线程的抽象  Runnable是业务逻辑任务的抽象
Thread线程类的常用方法：
start() 线程启动方法 多次调用会抛出异样;
run() 业务逻辑执行的方法
yeid() 让出CPU时间片 还可以继续获取时间片 进入 就绪状态
join()  等待其他线程执行  当前运行A线程  在A的内部调用 B.join() 则时间片切换给了B 等待B执行完成再执行A, A进入阻塞等待;
sleep() 进入阻塞Blocking状态 当前线程不释放资源锁；

Object.wait() 是Object的方法并不是Thread的方法; 释放锁进入队列等待获取锁。
Object.notify() 不会释放锁

##并发容器