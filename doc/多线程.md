#Excutors可以产生哪些线程池
newCachedThreadPool  可缓存的线程池  可灵活回收空闲线程
newFixedThreadPool 定长线程池  控制线程的最大并发数  超出会在队列中等待
newScheduledThreadPool 创建一个定长线程池 支持定时和周期性任务
newSingleThreadExecutor 单线程化的线程池 只有一个工作线程来执行任务 有顺序的执行

##线程池的参数
public ThreadPoolExecutor(int corePoolSize, 
int maximumPoolSize, 
long keepAliveTime,
 TimeUnit unit, 
 BlockingQueue workQueue, 
 ThreadFactory threadFactory)
 { this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler);

#线程池的饱和策略： 
1.Abort策略:默认策略,新任务提交时直接抛出未检查的异常RejectedExecutionException 
2.CallerRuns策略:为调节机制,既不抛弃任务也不抛出异常,而是将某些任务回退到调用者不会在线程池的线程中执行新的任务，而是在调用exector的线程中运行新的任务。
3.Discard策略:新提交的任务被抛弃。 new ThreadPoolExecutor().DiscardPolicy() 
4.DiscardOldest策略:队列的是“队头”的任务,然后尝试提交新的任务。对头任务被丢弃（不适合工作队列为优先队列场景）


~新建线程的两种方式  extends Thread 或 implements Runnable接口
Thread是线程的抽象  Runnable是业务逻辑任务的抽象
Thread线程类的常用方法：
start() 线程启动方法 多次调用会抛出异样;
run() 业务逻辑执行的方法
yeid() 让出CPU时间片 还可以继续获取时间片 进入 就绪状态 不释放锁
join()  等待其他线程执行  当前运行A线程  在A的内部调用 B.join() 则时间片切换给了B 等待B执行完成再执行A, A进入阻塞等待;
sleep() 进入阻塞Blocking状态 当前线程不释放资源锁；

Object.wait() 是Object的方法并不是Thread的方法; 释放锁进入队列等待获取锁。
Object.notify() 不会释放锁

Thread-> ThreadLocal->ThreadLocalMap->
InheritableThreadLocal extends ThreadLocal  父线程生成的变量需要传递到子线程中进行使用
ThrealLocal引用指向ThreadLocalMap 弱引用，由于map和现场thread生命周期一样长，但是弱引用的ThrealLoacl
在GC时会被回收，threadLocal=null后，map中就存在key=null的value；那么value就无法被访问到了故存在内存泄漏。
故使用的时候结束后调用remove方法。

set()
get()
remove()
Fork-join原理  将一个大任务 拆分(fork)成多个小任务,然后把小任务的计算结果join
##并发工具 AbstractQueuedSynchronizer
CountDownLatch(CDL) 发令枪 通过AQS AbstractQueuedSynchronizer实现  让一个现场等待其他线程完成各自的工作在执行。
构造参数 int 和线程没有关系;

CyclicBarrier(CB)  循环屏障 ReentrantLock实现 让一组现场到达屏障点阻塞，直到最后一个线程达到屏障才可以继续运行。
构造参数int和线程数密切相关
await()方法表示到达屏障等待；也可以到达屏障执行一个Runnable任务。
cdl的计数器只能使用一次，CB的可以循环使用;

Semaphore 信号量 通过AQS实现 同时支持N个线程运行, 流量控制
注意事项：

FutureTask 整合了 Future Runnable Callable 三个接口  既可以把Callable当作Thread的构造参数也可以获取线程的执行结果。
#CAS 乐观锁机制 Comapre and swap   存在ABA问题  开销问题  只能保证一个共享变量的原子操作
处理器 cas指令(内存地址，oldvalue,newValue)  自旋
aba问题可以通过版本号解决。
原子操作类 AtomicReference<> 更新引用类
带版本号的原子操作类。
 AtomicMarkableReference  表示是否被改变过 有个boolean类型
 AtomicStampedReference   表示修改过多少次 有个Integer类型的版本号





