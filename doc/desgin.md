
	
设计模式：
	创建型模式
		工厂方法模式：FactoryMethod 定一个创建对象的接口，具体实例化那个对象由子类决定。
		抽象工厂模式：Abstract Factory 创建一系列相关或相互依赖的接口。
		建造者模式：Builder   ConcentrateBuilder具体建造者 Builder  Director 指挥者 复杂对象的构建和表示分离。同样的创建过程可以创建不同的表示。
		原形模式：Prototype 原型实例指定创建对象的种类，通过拷贝原型创建新对象。
					client 调用 clone方法即可。
		单例模式： Singleton 保证一个类仅有一个实例。
	结构型设计模式
	
		适配器模式：Adapter 将一个类的接口转换成客户希望的另外一个接口。适用于 想使用一个已存在的类，但是接口不符合需求
					client--target--adapter
					
		桥接模式：Bridge  将抽象部分和实现分离，都可以独立的变化，连接类的功能层次结构和实现层次结构  统一接口。
		
		组合模式:Composite  将对象组合层树结构  表示部分-整体的层次结构
		
		装饰着模式：Decorator  动态的给对象添加一些额外的功能，比生成子类更灵活，动态扩展
		外观模式：Facade  为子系统中的一组接口提供一个一致的界面，提供一个高层接口，隔离了外部系统和子系统复杂的交互。
					统一的一个入口。
		享元模式：FlyWeight Pattern 运用共享技术有效支持大量的对象。对象的复用。
		
		代理模式：Proxy Pattern  使用代理对象完成用户请求，屏蔽用户对真实对象的访问。 接口相同   增强
		
	行为型设计模式：
		
		责任链模式：Chain of Responsibility Pattern 避免请求发送者和接收者耦合，让多个对象都收到请求。
					多个对象连成一个链条传递请求。  如 申请报销费用
		解释器模式： Interpreter pattern
		模板方法模式： Template Pattern  定义模板接口方法，具体步骤延伸到子类实现。  如JDBCTemplate  RestTemplate
		
		命令模式：Command Pattern  可撤销  发送命令和执行命令分开。  如 手动按电视机按钮 而不是用遥控器。  
		迭代器模式： Iterator Pattern 提供一种方法顺序的访问聚合对象中各个元素。不用暴露内部
		中介者模式：Mediator Pattern  中介对象封装一系列的对象交互  解耦
		备忘录模式： Memento Pattern  不破坏封装性的前提，捕获对象的内部状态。  存储到外部。
		
		观察者模式：Observer Pattern 发布订阅 一对多的关系，一个对象变更，所有依赖他的对象都发生改变。
		状态模式：State Pattern  对象内部状态，不同状态有不同的行为。 状态单独封装成类。
		策略模式： Strategy Pattern  算法独立  相互替换。
		访问者模式：Visitor Pattern    对于某个对象 不同访问者 产生的结果不同 执行操作也不同; 数据结构和处理分离。
				如 处方单对象处理：财务室是计算处方单的总价   药房是根据处方取药。
		
设计原则： 6大原则
	单一职责原则：  一个类只负责一项职责 
			优点：降低类的复杂度、提高类的可读性和可维护性、变更引起的风险降低。
	里氏替换原则：  所有引用基类的地方必须能透明的使用其子类。  子类继承父类新增功能时不能改变父类的原有功能。
	依赖倒置原则： 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象
				面向接口编程  
	接口隔离原则： 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。
	迪米特原则：一个对象应该对其他对象保持最少的了解   保持低耦合 
	开闭原则： 对扩展开放 对修改关闭
	
				
			
			
			
			
	
	
			
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
 